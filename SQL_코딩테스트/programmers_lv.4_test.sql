-- 1. 보호소에서 중성화한 동물
-- 0912 6분27초
SELECT I.ANIMAL_ID
     , I.ANIMAL_TYPE
     , I.NAME
FROM (SELECT *
      FROM ANIMAL_INS
      WHERE SEX_UPON_INTAKE LIKE 'Intact%') I
JOIN (SELECT *
           FROM ANIMAL_OUTS
           WHERE SEX_UPON_OUTCOME LIKE 'Spayed%'
              OR SEX_UPON_OUTCOME LIKE 'Neutered%') O
ON I.ANIMAL_ID = O.ANIMAL_ID
ORDER BY 1


-- 2. 식품분류별 가장 비싼 식품의 정보 조회하기
-- 0912 4분 9초
SELECT CATEGORY
     , PRICE AS MAX_PRICE
     , PRODUCT_NAME
FROM FOOD_PRODUCT
WHERE (CATEGORY, PRICE) 
   IN (SELECT CATEGORY
            , MAX(PRICE) AS MAX_PRICE
       FROM FOOD_PRODUCT
       WHERE CATEGORY IN ('과자', '국', '김치', '식용유')
       GROUP BY CATEGORY)
ORDER BY 2 DESC


-- 3. 5월 식품들의 총매출 조회하기
-- 0912 6분 10초
SELECT O.PRODUCT_ID
     , PRODUCT_NAME
     , SUM(AMOUNT*PRICE) AS TOTAL_SALES
FROM (SELECT *
      FROM FOOD_ORDER
      WHERE PRODUCE_DATE LIKE '2022-05%') O
JOIN FOOD_PRODUCT P
ON O.PRODUCT_ID = P.PRODUCT_ID
GROUP BY 1, 2
ORDER BY 3 DESC, 1


-- 4. 취소되지 않은 진료 예약 조회하기
-- 0912 15분 35초
SELECT A.APNT_NO
     , PT_NAME
     , A.PT_NO
     , A.MCDP_CD
     , DR_NAME
     , A.APNT_YMD
FROM (SELECT *
      FROM APPOINTMENT
      WHERE APNT_YMD LIKE '2022-04-13%'
        AND APNT_CNCL_YN = 'N'
        AND MCDP_CD = 'CS') A
LEFT JOIN PATIENT P
ON A.PT_NO = P.PT_NO
JOIN DOCTOR D
ON A.MDDR_ID = D.DR_ID
ORDER BY 6


-- 5. 서울에 위치한 식당 목록 출력하기
-- 0912 9분 24초
SELECT I.REST_ID
     , REST_NAME
     , FOOD_TYPE
     , FAVORITES
     , ADDRESS
     , SCORE
FROM (SELECT *
      FROM REST_INFO
      WHERE ADDRESS LIKE '서울%') I
JOIN (SELECT REST_ID
                , ROUND(AVG(REVIEW_SCORE), 2) AS SCORE
           FROM REST_REVIEW
           GROUP BY REST_ID) R
ON I.REST_ID = R.REST_ID
ORDER BY SCORE DESC, FAVORITES DESC


-- 6. 년, 월, 성별 별 상품 구매 회원 수 구하기
-- 0912 9분 38분
WITH TEMP_SALE AS (
SELECT S.USER_ID
     , SALES_AMOUNT
     , SALES_DATE
     , GENDER
FROM ONLINE_SALE S
LEFT JOIN USER_INFO I
ON S.USER_ID = I.USER_ID
WHERE GENDER IS NOT NULL
)
SELECT YEAR(SALES_DATE)
     , MONTH(SALES_DATE)
     , GENDER
     , COUNT(DISTINCT USER_ID) AS USERS
FROM TEMP_SALE
GROUP BY 1, 2, 3
ORDER BY 1, 2, 3


-- 7. 저자별 카테고리별 매출액 집계하기
-- 0912 13분 11초
SELECT B.AUTHOR_ID
     , AUTHOR_NAME
     , CATEGORY
     , SUM(SALES*PRICE) AS TOTAL_SALES
FROM BOOK B
JOIN (SELECT BOOK_ID
           , SUM(SALES) AS SALES
      FROM BOOK_SALES
      WHERE SALES_DATE LIKE '2022-01%'
      GROUP BY BOOK_ID) S
ON B.BOOK_ID = S.BOOK_ID
JOIN AUTHOR A
ON B.AUTHOR_ID = A.AUTHOR_ID
GROUP BY 1, 2, 3
ORDER BY 1, 3 DESC


-- 8. 우유와 요거트가 담긴 장바구니
-- 0912 25분 56초
SELECT CART_ID
FROM (SELECT CART_ID
           , NAME
           , IF(NAME='Yogurt', 1, 2) AS NM_CD
      FROM CART_PRODUCTS
      WHERE NAME IN ('Milk', 'Yogurt')
      GROUP BY CART_ID, NAME) P
GROUP BY CART_ID
HAVING COUNT(NAME) >= 2


-- 9. 주문량이 많은 아이스크림들 조회하기
-- 0912 6분 59초
SELECT FH.FLAVOR
FROM (SELECT FLAVOR
           , SUM(TOTAL_ORDER) AS FH_ORDER
      FROM FIRST_HALF
      GROUP BY FLAVOR) FH
JOIN (SELECT FLAVOR
           , SUM(TOTAL_ORDER) AS JUL_ORDER
      FROM JULY
      GROUP BY FLAVOR) J
ON FH.FLAVOR = J.FLAVOR
ORDER BY (FH_ORDER+JUL_ORDER) DESC
LIMIT 3


-- 10. 그룹별 조건에 맞는 식당 목록 출력하기
-- 0912 19분 6초
WITH TEMP_RANK AS (
SELECT MEMBER_ID
     , DENSE_RANK() OVER(ORDER BY COUNT(*) DESC) AS RNK
FROM REST_REVIEW
GROUP BY 1
)
SELECT MEMBER_NAME
     , REVIEW_TEXT
     , DATE_FORMAT(REVIEW_DATE, '%Y-%m-%d') AS REVIEW_DATE
FROM REST_REVIEW R
LEFT JOIN MEMBER_PROFILE P
ON R.MEMBER_ID = P.MEMBER_ID
WHERE R.MEMBER_ID IN (SELECT MEMBER_ID
                      FROM TEMP_RANK
                      WHERE RNK = 1)
ORDER BY 3, 2


-- 11. 연간 평가점수에 해당되는 평가 등급 및 성과금 조회하기
-- 0912 8분 47초
WITH TEMP_GRADE AS (
SELECT EMP_NO
     , CASE WHEN AVG(SCORE) >= 96 THEN 'S'
            WHEN AVG(SCORE) >= 90 THEN 'A'
            WHEN AVG(SCORE) >= 80 THEN 'B'
            ELSE 'C'
       END AS GRADE
     , CASE WHEN AVG(SCORE) >= 96 THEN 0.2
            WHEN AVG(SCORE) >= 90 THEN 0.15
            WHEN AVG(SCORE) >= 80 THEN 0.1
            ELSE 0
       END AS BONUS
FROM HR_GRADE
GROUP BY EMP_NO
)
SELECT G.EMP_NO
     , EMP_NAME
     , GRADE
     , SAL*BONUS AS BONUS
FROM TEMP_GRADE G
LEFT JOIN HR_EMPLOYEES E
ON G.EMP_NO = E.EMP_NO
ORDER BY 1


-- 12. 오프라인/온라인 판매 데이터 통합하기
-- 0912 12분 44초
SELECT DATE_FORMAT(SALES_DATE, '%Y-%m-%d')
     , PRODUCT_ID
     , USER_ID
     , SALES_AMOUNT
FROM ONLINE_SALE
WHERE SALES_DATE LIKE '2022-03%'
UNION ALL
SELECT DATE_FORMAT(SALES_DATE, '%Y-%m-%d') AS SALES_DATE
     , PRODUCT_ID
     , NULL AS USER_ID
     , SALES_AMOUNT
FROM OFFLINE_SALE
WHERE SALES_DATE LIKE '2022-03%'
ORDER BY 1, 2, 3


-- 13. 입양 시각 구하기(2)
-- 0912 7분 17초
WITH RECURSIVE TEMP_HOUR AS (
SELECT 0 AS HOUR
UNION ALL
SELECT HOUR + 1 AS HOUR
FROM TEMP_HOUR
WHERE HOUR < 23
),
TEMP_OUTS AS (
SELECT HOUR(DATETIME) AS HOUR
     , COUNT(*) AS COUNT
FROM ANIMAL_OUTS H
GROUP BY 1
)
SELECT H.HOUR
     , IF(COUNT IS NULL, 0, COUNT) AS COUNT
FROM TEMP_HOUR H
LEFT JOIN TEMP_OUTS O
ON H.HOUR = O.HOUR
ORDER BY 1


-- 14. 특정 세대의 대장균 찾기
-- 0912 4분 28초
SELECT ID
FROM ECOLI_DATA
WHERE PARENT_ID IN (
        SELECT ID
        FROM ECOLI_DATA
        WHERE PARENT_ID IN (SELECT ID
                            FROM ECOLI_DATA
                            WHERE PARENT_ID IS NULL)
)
ORDER BY 1


-- 15. 자동차 대여 기록 별 대여 금액 구하기
-- 0912 23분 56초
WITH TEMP_HISTORY AS (
SELECT HISTORY_ID, H.CAR_ID
     , (DATEDIFF(END_DATE, START_DATE)+1)*DAILY_FEE AS FEE
     , CASE WHEN DATEDIFF(END_DATE, START_DATE)+1 >= 90 THEN '90일 이상'
            WHEN DATEDIFF(END_DATE, START_DATE)+1 >= 30 THEN '30일 이상'
            WHEN DATEDIFF(END_DATE, START_DATE)+1 >= 7 THEN '7일 이상'
            ELSE DATEDIFF(END_DATE, START_DATE)+1
       END AS DURATION_TYPE
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY H
LEFT JOIN CAR_RENTAL_COMPANY_CAR C
ON H.CAR_ID = C.CAR_ID
WHERE CAR_TYPE = '트럭'
)
SELECT HISTORY_ID
     , IF(P.DURATION_TYPE, ROUND(FEE*(1-DISCOUNT_RATE/100), 0), ROUND(FEE, 0)) AS FEE
FROM TEMP_HISTORY H
LEFT JOIN (SELECT *
           FROM CAR_RENTAL_COMPANY_DISCOUNT_PLAN
           WHERE CAR_TYPE = '트럭') P
ON H.DURATION_TYPE = P.DURATION_TYPE
GROUP BY 1
ORDER BY 2 DESC, 1 DESC


-- 16. 특정 기간 동안 대여 가능한 자동차들의 대여비용 구하기
-- 0912 50분 실패
WITH TEMP_CAR AS (
SELECT DISTINCT H.CAR_ID
     , CAR_TYPE
     , DAILY_FEE
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY H
LEFT JOIN CAR_RENTAL_COMPANY_CAR C
ON H.CAR_ID = C.CAR_ID
AND CAR_TYPE IN ('세단', 'SUV')
WHERE START_DATE > '2022-11-30' OR END_DATE < '2022-11-01'
)
SELECT CAR_ID
     , C.CAR_TYPE
     , ROUND(DAILY_FEE*30*(1-DISCOUNT_RATE/100), 0) AS FEE
FROM TEMP_CAR C
LEFT JOIN (SELECT *
           FROM CAR_RENTAL_COMPANY_DISCOUNT_PLAN
           WHERE DURATION_TYPE = '30일 이상') P
ON C.CAR_TYPE = P.CAR_TYPE
WHERE C.CAR_TYPE IS NOT NULL
ORDER BY 3 DESC, 2, 1 DESC
-- 0914 20분
WITH TEMP_DURATION AS (
SELECT H.CAR_ID
     , CAR_TYPE
     , DAILY_FEE
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY H
LEFT JOIN CAR_RENTAL_COMPANY_CAR C
ON H.CAR_ID = C.CAR_ID
WHERE START_DATE > '2022-11-30'
   OR END_DATE < '2022-11-01'
),
TEMP_FEE AS (
SELECT DISTINCT CAR_ID
     , D.CAR_TYPE
     , ROUND(DAILY_FEE*30*(1-DISCOUNT_RATE/100), 0) AS FEE
FROM TEMP_DURATION D
JOIN CAR_RENTAL_COMPANY_DISCOUNT_PLAN P
ON D.CAR_TYPE = P.CAR_TYPE
WHERE D.CAR_TYPE IN ('세단', 'SUV')
  AND DURATION_TYPE = '30일 이상'
)
SELECT * 
FROM TEMP_FEE
WHERE FEE >= 500000
  AND FEE < 2000000
ORDER BY FEE DESC
       , CAR_TYPE
       , CAR_ID DESC
-- 0918
WITH TEMP_NOV AS (
SELECT DISTINCT CAR_ID
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY H1
WHERE NOT EXISTS (SELECT *
                  FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY H2
                  WHERE H1.CAR_ID = H2.CAR_ID
                    AND START_DATE <= '2022-11-30'
                    AND END_DATE >= '2022-11-01')
),  -- 11월에 대여 가능한 차량
TEMP_DURATION AS (
SELECT *
FROM CAR_RENTAL_COMPANY_DISCOUNT_PLAN
WHERE DURATION_TYPE = '30일 이상'
)  -- 30일 이상인 경우의 할인 정책
SELECT C.CAR_ID
     , C.CAR_TYPE
     , ROUND(DAILY_FEE*30*(1-DISCOUNT_RATE/100), 0) AS FEE
FROM CAR_RENTAL_COMPANY_CAR C
JOIN TEMP_NOV N
ON C.CAR_ID = N.CAR_ID
JOIN TEMP_DURATION D
ON C.CAR_TYPE = D.CAR_TYPE
WHERE C.CAR_TYPE IN ('세단', 'SUV')
  AND (DAILY_FEE*30*(1-DISCOUNT_RATE/100)) >= 500000 
  AND (DAILY_FEE*30*(1-DISCOUNT_RATE/100)) < 2000000
ORDER BY 3 DESC, 2, 1 DESC


-- 17. FrontEnd 개발자 찾기
-- 0921 15분
SELECT ID
     , EMAIL
     , FIRST_NAME
     , LAST_NAME
FROM DEVELOPERS D
JOIN SKILLCODES S
ON D.SKILL_CODE & S.CODE = S.CODE  -- skill_code와 code가 일치하는 경우
WHERE CATEGORY = 'Front End'
ORDER BY ID