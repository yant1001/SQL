-- 1. 자동차 종류 별 특정 옵션이 포함된 자동차 수 구하기
SELECT CAR_TYPE,
       COUNT(CAR_TYPE) AS CARS
FROM CAR_RENTAL_COMPANY_CAR
WHERE OPTIONS LIKE '%통풍시트%'
    OR OPTIONS LIKE '%열선시트%'
    OR OPTIONS LIKE '%가죽시트%'
GROUP BY 1
ORDER BY 1


-- 2. 성분으로 구분한 아이스크림 총 주문량
SELECT INGREDIENT_TYPE,
       SUM(TOTAL_ORDER) AS TOTAL_ORDER
FROM FIRST_HALF A
JOIN ICECREAM_INFO B
    ON A.FLAVOR = B.FLAVOR
GROUP BY INGREDIENT_TYPE


-- 3. 진료과별 총 예약 횟수 출력하기
SELECT MCDP_CD AS '진료과 코드',
       COUNT(PT_NO) AS '5월예약건수'
FROM APPOINTMENT
WHERE DATE_FORMAT(APNT_YMD, '%Y-%m') = '2022-05'
GROUP BY 1
ORDER BY 2, 1


-- 4. 고양이와 개는 몇 마리 있을까
SELECT ANIMAL_TYPE,
       COUNT(ANIMAL_ID) AS count
FROM ANIMAL_INS
GROUP BY ANIMAL_TYPE
ORDER BY 1


-- 5. 동명 동물 수 찾기
SELECT NAME,
       COUNT(NAME) AS COUNT
FROM ANIMAL_INS
GROUP BY NAME
HAVING COUNT(NAME) >= 2
ORDER BY 1


-- 6. 입양 시각 구하기(1)
SELECT HOUR(DATETIME) AS HOUR,
       COUNT(ANIMAL_ID) AS COUNT
FROM ANIMAL_OUTS
WHERE HOUR(DATETIME) BETWEEN 9 AND 19
GROUP BY 1
ORDER BY 1

-- 7. 가격대별 상품 개수 구하기
WITH TEMP_PR_GR AS (
SELECT
    *,
    CASE WHEN PRICE < 10000 THEN 0
         WHEN PRICE < 20000 THEN 10000
         WHEN PRICE < 30000 THEN 20000
         WHEN PRICE < 40000 THEN 30000
         WHEN PRICE < 50000 THEN 40000
         WHEN PRICE < 60000 THEN 50000
         WHEN PRICE < 70000 THEN 60000
         WHEN PRICE < 80000 THEN 70000
         WHEN PRICE < 90000 THEN 80000
         ELSE NULL END AS PRICE_GROUP
FROM PRODUCT
)
SELECT PRICE_GROUP,
       COUNT(PRODUCT_CODE) AS PRODUCTS
FROM TEMP_PR_GR
GROUP BY PRICE_GROUP
ORDER BY 1
--- 같은 문제에서 좋다고 생각한 다른 분 풀이
SELECT A.PRICE_GROUP, 
	     COUNT(A.PRODUCT_ID) AS PRODUCTS
FROM
	(SELECT *, 
		      TRUNCATE(PRICE, -4) AS PRICE_GROUP
	 FROM PRODUCT) A
GROUP BY 1
ORDER BY 1 ASC


-- 8. 조건에 맞는 사원 정보 조회하기
SELECT SUM(SCORE) AS SCORE,
       EMP.EMP_NO,
       EMP.EMP_NAME,
       EMP.POSITION,
       EMP.EMAIL
FROM HR_EMPLOYEES EMP
JOIN HR_DEPARTMENT DEPT
ON EMP.DEPT_ID = DEPT.DEPT_ID
JOIN HR_GRADE GR
ON EMP.EMP_NO = GR.EMP_NO
WHERE GR.YEAR = 2022
GROUP BY EMP.EMP_NO
ORDER BY 1 DESC
LIMIT 1


-- 9.노선별 평균 역 사이 거리 조회하기
SELECT ROUTE, 
       CONCAT(ROUND(SUM(D_BETWEEN_DIST), 1), 'km') AS TOTAL_DISTANCE,
       CONCAT(ROUND(AVG(D_BETWEEN_DIST), 2), 'km') AS AVERAGE_DISTANCE
FROM SUBWAY_DISTANCE
GROUP BY ROUTE
ORDER BY SUM(D_BETWEEN_DIST) DESC


-- 10. 물고기 종류 별 잡은 수 구하기
SELECT COUNT(FI.FISH_TYPE) AS FISH_COUNT,
       FISH_NAME
FROM FISH_INFO FI
JOIN FISH_NAME_INFO NI
ON FI.FISH_TYPE = NI.FISH_TYPE
GROUP BY FISH_NAME
ORDER BY 1 DESC


-- 11. 월별 잡은 물고기 수 구하기
SELECT COUNT(FISH_TYPE) AS FISH_COUNT,
       MONTH(TIME) AS MONTH
FROM FISH_INFO
GROUP BY 2
ORDER BY 2


-- 12. 카테고리 별 도서 판매량 집계하기
SELECT CATEGORY,
       SUM(SALES) AS TOTAL_SALES
FROM BOOK_SALES S
LEFT JOIN BOOK B
ON S.BOOK_ID = B.BOOK_ID
WHERE DATE_FORMAT(SALES_DATE, '%Y-%m') = '2022-01'
GROUP BY CATEGORY
ORDER BY 1


-- 13. 대여 횟수가 많은 자동차들의 월별 대여 횟수 구하기
SELECT MONTH(START_DATE) AS MONTH,
       CAR_ID,
       COUNT(HISTORY_ID) AS RECORDS
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
WHERE DATE_FORMAT(START_DATE, '%Y-%m') BETWEEN '2022-08' AND '2022-10'
AND CAR_ID IN (SELECT CAR_ID
               FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
               WHERE DATE_FORMAT(START_DATE, '%Y-%m') BETWEEN '2022-08' AND '2022-10'
               GROUP BY 1
               HAVING COUNT(HISTORY_ID) >= 5)
GROUP BY 1, 2
ORDER BY 1, 2 DESC


-- 14. 즐겨찾기가 가장 많은 식당 정보 출력하기
-- GROUP BY: 그룹화에 사용한 컬럼만 SELECT 절에 직접 명시 후 나머지 컬럼에 대해서는 집계 결과만 적을 수 있습니다.
--           예를 들어 SELECT FOOD_TYPE, COUNT(*)
-- HAVING: HAVING절 사용 시 조건이 필요합니다. 조건 미입력시 첫번째 레코드가 선택되어 출력되는 오류가 생깁니다.
--         예를 들어 MAX(FAVORITES) > 1000과 같이 사용해야 합니다.
SELECT FOOD_TYPE,
       REST_ID,
       REST_NAME,
       FAVORITES
FROM REST_INFO
WHERE (FOOD_TYPE, FAVORITES) IN (SELECT FOOD_TYPE, MAX(FAVORITES)
                                 FROM REST_INFO
                                 GROUP BY FOOD_TYPE)
ORDER BY 1 DESC


-- 15. 자동차 대여 기록에서 대여중 / 대여 가능 여부 구분하기
-- CASE WHEN THEN 구문에서 MAX를 쓰게 되면, 사전순으로 비교되어 유니코드 기준 각 글자의 코드 포인트로 계산 시 
-- '대여중'이 '대여 가능'보다 더 큰 값으로 간주되기 때문에 더 높은 우선순위를 갖는다.
SELECT CAR_ID,
       MAX(CASE WHEN START_DATE <= '2022-10-16' AND END_DATE >= '2022-10-16'
           THEN '대여중'
           ELSE '대여 가능'
           END) AS AVAILABILITY
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
GROUP BY CAR_ID
ORDER BY CAR_ID DESC


